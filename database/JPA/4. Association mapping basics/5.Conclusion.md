# 정리!

* 연관관계 매핑시 고려해야 하는 것
    1. 다중성 - 1:N? N:M? / ManyToOne? OneToMany? OneToOne? ManyToMany?
    2. 단방향/양방향
    3. 연관관계의 주인
* 복잡도는 **단방향 매핑 <<< 양방향 매핑** 정도의 차이가 난다.
    * 연관관계의 주인 설정, 그에따른 로직 변경 등의 추가적인 작업이 필요하다.
* 양방향 매핑으로 변경되는것은, 주인이 아닌 연관관계를 하나 추가한것일 뿐이며, 단방향에서 반대의 객체 그래프 탐색 기능이 추가된 것이다.
* 전체적인 정리는 다음과 같다.
    1. 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료된 것이다.
    2. 단방향을 양방향으로 만들려면 반대방향으로 객체 그래프 탐색 기능이 추가되어야 한다.
    3. 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야만 한다.
    4. 양방향은 연관관계의 주인을 정해야 하는데, 이는 데이터베이스에서 해당 외래키를 관리할 수 있는 테이블이 가지게 된다. 
        * 쉽게 생각하면 해당 정보를 컬럼으로 가질 수 있는 테이블 및 N(다) 의 관계를 가진 곳이 연관관계의 주인이 된다.
        * 즉, 엔티티에서 연관관계의 값을 가지는 엔티티쪽이 연관관계의 주인이 된다.
* **주의할 점!**
    * 양방향 매핑 시에는 무한 루프에 빠지지 않게 조심해야 한다.
    * toString() 을 사용하는 JSON 을 리턴해주는 형태에서 많이 발생한다.

```java
Member member = new Member(1, "Foo");
Team team = new Team(1, "Bar");

member.setTeam(team);
// 3 번에서 변경한 setTeam 로직에 의해 team 에도 해당 멤버가 추가된다.

member.toString();

// member 의 team 의 toString() 이 호출
// team 의 members 안의 member 들의 toString() 이 호출되는데, 해당 members 에 Id 가 1인 멤버가 존재한다.
// 다시 위의 member 가 toString() 을 호출하면서 team toString, member toString ..... 반복하면서 stackOverflow 가 발생한다.
// toString() 은 대표적으로 JSON 으로 응답을 줄 때 사용된다.
```
