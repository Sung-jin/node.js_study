## 영속성 컨텍스트란?

* persistence context
* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
* em.persist(entity); 를 사용할 때 엔티티 매니저를 사용해서 해당 엔티티를 영속성 컨텍스트에 저장하는 것이다.
* 그래서?
    1. 영속성 컨텍스트는 논리적인 개념에 가깝다.
    2. 엔티티 매니저를 생성할 때 하나 생성된다.
    3. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 관리할 수 있다.

## 엔티티의 생명주기

* 엔티티에는 4개의 상태가 존재한다.
    1. 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
    2. 영속 (managed) : 영속성 컨텍스트에 저장된 상태
    3. 준영속 (detached) : 영속성 컨텓ㄱ스트에 저장되었다가 분리된 상태
    4. 삭제 (removed) : 삭제된 상태

![entity life cycle](../images/2.%20entity%20life%20cycle.png)

* 비영속
    * 엔티티 객체를 생성한 상태이며, 저장 직전인 객체를 말한다.
    * 즉, 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.

```java
Member mebmer = new Member();
member.setId(1);
member.setName("오성진");
```

* 영속
    * 엔티티 매니저를 통해 엔티티 객체를 영속성 컨텍스트에 저장한 상태.
    * 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
    * 즉, **영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻** 이다.
* 준영속
    * 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
    * em.detach(), em.close(), em.clear() 를 사용해서 영속성 컨텍스트를 준영속으로 만들거나, 닫거나, 초기화하면 영속 상태의 엔티티는 준영속 상태가 된다.
* 삭제
    * em.remove() 를 통해서 엔티티를 영속성 컨텍스트와 데잍처베이스에서 삭제한다.

## 영속성 컨텍스트의 특징

* 영속성 컨텍스트와 식별자 값
    * 영속성 컨텍스트는 엔티티를 식별자 값(@id 로 테이블의 기본 키와 매핑한 값) 으로 구분한다.
    * **영속 상태는 식별자 값이 반드시 있어야 한다.**
        * 식별자 값이 없을 경우 예와가 발생한다.
* 영속성 컨텍스트와 데이터베이스 저장
    * 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush 라고 한다.
* 영속성 컨텍스트가 엔티티를 관리하면 장점
    1. 1차 캐시
    2. 동일성 보장
    3. 트랜잭션을 지원하는 쓰기 지연
    4. 변경 감지
    5. 지연 로딩

### 엔티티 조회

* 영속성 컨텍스트는 내부에 캐시를 가지고 있는데, 이를 1차 캐시라고 한다.
* 영속 상태의 엔티티는 모두 1차 캐시에 저장된다.
    * 영속성 컨텍스트 내부에 Map<@Id, Entity> 형태의 맵이 있다.
    * 키 값이 데이터베이스의 기본키와 매핑되어 있다. 즉, 영속성 컨텍스트 -> 데이터베이스로 저장, 조회할 때 모든 기준은 기본 키 값이다.

```java
// EntityManager().find()
public <T> T find(Class<T> entityClass, Object primaryKey);

// find() 를 호출하면 1차 캐시에서 엔티티를 찾고, 값이 없으면 데이터베이스에서 조회한다.

User user1 = em.find(User.class, 1);
User user2 = em.find(User.class, 1);
// user1 에서 찾은 값을 캐시에 저장하고, 같은 키값인 1을 조회하므로 캐시에 있는 값이 리턴된다.

user1 == user2; // true
// 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.
```

### 엔티티 등록

* 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL 을 모아둔다.
* 트랜잭션이 커밋되는 순간, 모인 쿼리를 데이터베이스에 전달한다.
    * 이를 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind) 이라 한다.
* 트랜잭션이 커밋되면 엔티티 매니저는 우선 영속성 컨텍스트를 flush 한다.
    * flush 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다.
    * 이 작업은 엔티티의 등록, 수정, 삭제를 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 반영한다.
    * 위의 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.

### 엔티티 수정

* SQL 을 사용하면 수정 쿼리를 직접 작성해야 한다.
    * 컬럼이 추가되거나, 변경되거나, 요구사항이 변하는 등의 이슈가 발생하면 그때그때 쿼리를 수정하거나 추가해야만 한다.
    * 모든 컬럼을 받아서 수정하는 쿼리를 작성 할 수 있지만, 데이터가 잘못 들어갈 경우 문제가 발생할 수 있다.
* SQL 을 직접 사용해서 수정 쿼리를 작성할 경우 문제점
    1. 수정 쿼리가 많아진다.
    2. 비즈니스 로직을 분석하기 위해 SQL 을 계속 확인해야 한다.
    3. 결국, 비즈니스 로직이 SQL 에 의존하게 된다.
* 변경감지
    * 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다.
    * flush 하는 순간에 스냅샷과 엔티티를 비교해서 변경된 부분을 찾아서 수정 쿼리를 생성하여 데이터베이스에 전송한다.
    * 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
* 변경감지 동작 순서
    1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 flush 가 호출된다.
    2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
    3. 변경된 엔티티가 존재하면, 수정 쿼리를 생성하여 쓰기 지연 SQL 저장소에 보낸다.
    4. 쓰기 지연 저장소의 SQL 을 데이터베이스에 전달한다.
    5. 데이터베이스 트랜잭션을 커밋한다.
* 변경감지 동작으로 업데이트되는 컬럼
    * 기본 전략은 변경된 컬럼 뿐 아니라, 모든 필드가 업데이트 된다.
    * 이는 다음과 같은 장점이 있다.
        1. 수정 쿼리가 항상 같다. -> 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용 할 수 있다.
        2. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한번 파싱된 쿼리를 재사용할 수 있다.
        3. 변경된 필드만 업데이트 쿼리를 만들고 싶다면, @DynamicUpdate 어노테이션을 엔티티의 컬럼에 사용해주면 된다.

### 엔티티 삭제

* em.remove(entity); 를 통해 삭제될 대상을 넘겨주면 해당 엔티티를 삭제 쿼리를 쓰기 지연 SQL 에 등록한다.
    * em.remove(entity); 를 하는 순간 entity 는 영속성 컨텍스트에서 바로 제거된다.
    * 이렇게 제거된 엔티티는 재사용하지 말고, 가비지 컬렉션의 대상이 되도록 두는 것이 좋다.
* 트랜잭션 커밋을 통해 flush 가 동작하면 삭제 쿼리가 데이터베이스에 전달된다.

## 플러시

* 플러시는 영속성 컨텍스의 변경 내용을 데이터베이스에 반영한다.
* 플러시가 동작하는 순서
    1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
    2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
    3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.
* 영속성 컨텍스트를 플러시하는 방법
    1. em.flush() 를 호출한다.
        * 직접 호출을 하면 해당 시점에 강제로 플러시를 한다.
        * 거의 직접 호출해서 사용하는일은 거의 없다.
    2. 트랜잭션 커밋이 실행되면 자동 호출된다.
        * 변경 내용을 데이터베이스에 전달해야 반영되므로, 트랜잭션을 커밋할 때 플러시가 자동으로 호출된다.
    3. JPQL 쿼리 실행 시 자동 호출된다.
        * JPQL, Criteria 같은 객체지향 쿼리를 호출할 때도 플러시가 실행된다.

```java
em.persist(entity1);
em.persist(entity2);
em.persist(entity3);

query = em.createQuery("SELECT e FROM entity e", Entity.class);
List<Entity> entities = query.getResultList();

// 위와 같이 entity 1,2,3 의 경우에는 영속성만 되어있고 데이터베이스에는 없다.
// 위 상황에서 select 를 사용할 경우 entity 1,2,3 에 대한 쿼리 결과는 없을 것이다.
// 따라서 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영해야 한다.
// 참고로 식별자를 기준으로 조회하는 find() 메소드를 호출할 때는 플러시가 실행되지 않는다.
```

* 플러시 모드
    * FlushModeType 을 통해 지정할 수 있다.
        * FlushModeType.AUTO    : 커밋이나 쿼리를 실행할 때 (기본)
        * FlushModeType.COMMIT  : 커밋할 때만 플러시
    * **플러시라는 이름 때문에 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안된다.**
    * **영속성 컨텍스트의 변경 내용을 데이터 베이스에 동기화하는 것이 플러시이다.**

## 준영속

* 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태라고 한다.
* 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.
* 준영속 상태로 만드는 방법
    1. em.detach(entity);   : 특정 엔티티만 준영속 상태로 전환
    2. em.clear();          : 영속성 컨텍스트를 완전히 초기화한다.
    3. em.close();          : 영속성 컨텍스트를 종료한다.
    
### detach()

```java
Entity entity = new Entity();
entity.setValue("value");

em.persist(entity);

em.detach(entity);

transaction.commit();

// persist 를 통해 영속화를 진행하였지만, detach() 를 호출하여 준영속 상태로 만들었다.
// 준영속 상태가 되면 해당 엔티티는 영속성 컨텍스트에 의해 더이상 관리되지 않는다.
// 즉, 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.
```

### clear()

```java
Entity entity = em.find(Entity.class, "entity");

em.clear(); // 영속성 컨텍스트 초기화

entity.setValue("value");

// 위와같이 em.clear() 를 호출하는 순간 영속성 컨텍스트의 모든 영속성 속성들을 준영속 상태로 만든다.
// 즉, 위와같이 entity 가 영속성 상태이지만, clear() 가 호출 된 이후 준영속이 되었으므로 데이터가 변경되더라도
// 변경 감지는 동작하지 않으므로 데이터베이스에 반영되지 않는다.
```

### close()

* 영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다.
* 참고로 영속 상태의 엔티티는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 된다.
* 즉, 개발자가 직접 준영속 상태로 만드는 일은 드물다.

> em.close();

### 준영속 상태의 특징

* 거의 비영속 상태에 가깝다.
    * 영속성 컨텍스트가 관리하지 않으므로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등의 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.
* 식별자 값을 가지고 있다.
    * 비영속 상태는 식별자 값이 없을 수도 있지만, 준영속 상태는 이미 한 번 영속 상태였으므로 반드시 식별자 값을 가지고 있다.
* 지연 로딩을 할 수 없다.
    * 지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.
    * 준영속 상태는 영속성 컨텍스트가 더이상 관리하지 않으므로 지연 로딩 시 문제가 발생한다.

## 병합 (merge)

* 준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다.
* merge() 메소드를 통해서 준영속 상태의 엔티티를 해당 정보를 바탕으로 **새로운 영속 상태의 엔티티를 반환한다**.

```java
tx.begin();

Entity entity = new Entity("name", "value");
em.persist(entity);

tx.commit();
em.close();

// em.close() 를 통해 entity 는 데이터베이스에 저장된 후 영속성 컨텍스의 모든 엔티티가 준영속 상태가 된다.

entity.setValue("changeValue");
// 준영속 상태의 객체이므로 값을 변경하더라도 데이터베이스에 적용되지 않는다.

tx.begin();

Entity entity2 = em.merge(entity);

tx.commit();
em.close();

// 준영속 된 객체를 merge() 를 통해 해당 객체의 정보를 바탕으로 새로운 영속 상태의 객체를 반환한다.
// 준영속 상태라고 하더라도 식별자 값이 있으므로 해당하는 데이터를 데이터베이스에서 가져오고, 준영속 상태에서 변경한 값도
// 변경되어 있으므로 commit() 을 통해 해당 변경사항이 데이터베이스에 반영된다.
```

## 정리

* 엔티티 매니저는 엔티티 매니저 팩토리에서 생성한다.
* J2SE 환경에서 엔티티 매니저를 만들면 내부에 영속성 컨텍스트도 함께 만들어지고, 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있다.
* 영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다.
* 영속성 컨텍스트는 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연/변경 감지/지연 로딩 기능의 특징을 가지고 있다.
* 영속성 컨텍스트에 저장한 엔티티는 플러시 시점에 데이터베이스에 반영된다.
    * 일반적으로 플러시 시점은 트랜잭션을 커밋할 때 플러시 된다.
* 영속성 컨텍스트에 의해 관리받던 영속 상태의 엔티티를 영속성 컨텍스트에 관리받지 못하게 될 수 있는데, 이때 준영속 상태의 엔티티라고 한다.
* 준영속 상태의 엔티티는 영속성 컨텍스트의 기능을 제공받지 못한다.
* 준영속 상태의 엔티티 정보를 바탕으로 병합하여, 해당 정보를 바탕으로 새로운 영속성 엔티티를 생성할 수 있다.
