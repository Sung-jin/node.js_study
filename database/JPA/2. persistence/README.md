## 영속성 컨텍스트란?

* persistence context
* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
* em.persist(entity); 를 사용할 때 엔티티 매니저를 사용해서 해당 엔티티를 영속성 컨텍스트에 저장하는 것이다.
* 그래서?
    1. 영속성 컨텍스트는 논리적인 개념에 가깝다.
    2. 엔티티 매니저를 생성할 때 하나 생성된다.
    3. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 관리할 수 있다.

## 엔티티의 생명주기

* 엔티티에는 4개의 상태가 존재한다.
    1. 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
    2. 영속 (managed) : 영속성 컨텍스트에 저장된 상태
    3. 준영속 (detached) : 영속성 컨텓ㄱ스트에 저장되었다가 분리된 상태
    4. 삭제 (removed) : 삭제된 상태

![entity life cycle](../images/2.%20entity%20life%20cycle.png)

* 비영속
    * 엔티티 객체를 생성한 상태이며, 저장 직전인 객체를 말한다.
    * 즉, 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.

```java
Member mebmer = new Member();
member.setId(1);
member.setName("오성진");
```

* 영속
    * 엔티티 매니저를 통해 엔티티 객체를 영속성 컨텍스트에 저장한 상태.
    * 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
    * 즉, **영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻** 이다.
* 준영속
    * 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
    * em.detach(), em.close(), em.clear() 를 사용해서 영속성 컨텍스트를 준영속으로 만들거나, 닫거나, 초기화하면 영속 상태의 엔티티는 준영속 상태가 된다.
* 삭제
    * em.remove() 를 통해서 엔티티를 영속성 컨텍스트와 데잍처베이스에서 삭제한다.

## 영속성 컨텍스트의 특징

* 영속성 컨텍스트와 식별자 값
    * 영속성 컨텍스트는 엔티티를 식별자 값(@id 로 테이블의 기본 키와 매핑한 값) 으로 구분한다.
    * **영속 상태는 식별자 값이 반드시 있어야 한다.**
        * 식별자 값이 없을 경우 예와가 발생한다.
* 영속성 컨텍스트와 데이터베이스 저장
    * 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush 라고 한다.
* 영속성 컨텍스트가 엔티티를 관리하면 장점
    1. 1차 캐시
    2. 동일성 보장
    3. 트랜잭션을 지원하는 쓰기 지연
    4. 변경 감지
    5. 지연 로딩

### 엔티티 조회

* 영속성 컨텍스트는 내부에 캐시를 가지고 있는데, 이를 1차 캐시라고 한다.
* 영속 상태의 엔티티는 모두 1차 캐시에 저장된다.
    * 영속성 컨텍스트 내부에 Map<@Id, Entity> 형태의 맵이 있다.
    * 키 값이 데이터베이스의 기본키와 매핑되어 있다. 즉, 영속성 컨텍스트 -> 데이터베이스로 저장, 조회할 때 모든 기준은 기본 키 값이다.

```java
// EntityManager().find()
public <T> T find(Class<T> entityClass, Object primaryKey);

// find() 를 호출하면 1차 캐시에서 엔티티를 찾고, 값이 없으면 데이터베이스에서 조회한다.

User user1 = em.find(User.class, 1);
User user2 = em.find(User.class, 1);
// user1 에서 찾은 값을 캐시에 저장하고, 같은 키값인 1을 조회하므로 캐시에 있는 값이 리턴된다.

user1 == user2; // true
// 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.
```

### 엔티티 등록

* 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL 을 모아둔다.
* 트랜잭션이 커밋되는 순간, 모인 쿼리를 데이터베이스에 전달한다.
    * 이를 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind) 이라 한다.
* 트랜잭션이 커밋되면 엔티티 매니저는 우선 영속성 컨텍스트를 flush 한다.
    * flush 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다.
    * 이 작업은 엔티티의 등록, 수정, 삭제를 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 반영한다.
    * 위의 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.

### 엔티티 수정

* SQL 을 사용하면 수정 쿼리를 직접 작성해야 한다.
    * 컬럼이 추가되거나, 변경되거나, 요구사항이 변하는 등의 이슈가 발생하면 그때그때 쿼리를 수정하거나 추가해야만 한다.
    * 모든 컬럼을 받아서 수정하는 쿼리를 작성 할 수 있지만, 데이터가 잘못 들어갈 경우 문제가 발생할 수 있다.
* SQL 을 직접 사용해서 수정 쿼리를 작성할 경우 문제점
    1. 수정 쿼리가 많아진다.
    2. 비즈니스 로직을 분석하기 위해 SQL 을 계속 확인해야 한다.
    3. 결국, 비즈니스 로직이 SQL 에 의존하게 된다.
* 변경감지
    * 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다.
    * flush 하는 순간에 스냅샷과 엔티티를 비교해서 변경된 부분을 찾아서 수정 쿼리를 생성하여 데이터베이스에 전송한다.
    * 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
* 변경감지 동작 순서
    1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 flush 가 호출된다.
    2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
    3. 변경된 엔티티가 존재하면, 수정 쿼리를 생성하여 쓰기 지연 SQL 저장소에 보낸다.
    4. 쓰기 지연 저장소의 SQL 을 데이터베이스에 전달한다.
    5. 데이터베이스 트랜잭션을 커밋한다.
* 변경감지 동작으로 업데이트되는 컬럼
    * 기본 전략은 변경된 컬럼 뿐 아니라, 모든 필드가 업데이트 된다.
    * 이는 다음과 같은 장점이 있다.
        1. 수정 쿼리가 항상 같다. -> 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용 할 수 있다.
        2. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한번 파싱된 쿼리를 재사용할 수 있다.
        3. 변경된 필드만 업데이트 쿼리를 만들고 싶다면, @DynamicUpdate 어노테이션을 엔티티의 컬럼에 사용해주면 된다.

### 엔티티 삭제

* em.remove(entity); 를 통해 삭제될 대상을 넘겨주면 해당 엔티티를 삭제 쿼리를 쓰기 지연 SQL 에 등록한다.
    * em.remove(entity); 를 하는 순간 entity 는 영속성 컨텍스트에서 바로 제거된다.
    * 이렇게 제거된 엔티티는 재사용하지 말고, 가비지 컬렉션의 대상이 되도록 두는 것이 좋다.
* 트랜잭션 커밋을 통해 flush 가 동작하면 삭제 쿼리가 데이터베이스에 전달된다.
