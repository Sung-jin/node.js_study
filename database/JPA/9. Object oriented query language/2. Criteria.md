### Criteria

* JPQL 을 자바 코드로 작성하도록 도와주는 빌더 클래스 API
* 문자가 아닌 코드로 JPQL 을 작성하므로 문법 오류를 컴파일 단계에서 잡을 수 있다.
* 문자 기반의 JPQL 보다 동적 쿼리를 안전하게 생성할 수 있는 장점이 존재한다.
* Criteria 만 사용할 경우 코드가 복잡해지는 단점이 존재한다.

#### Criteria 기초

```java
// JPQL : SELECT e FROM Entity e

CriteriaBuilder db = em.getCriteriaBuilder();
// 쿼리 빌더

CriteriaQuery<Entity> cq = cb.createQuery(Entity.class);
// 생성, 반환 타입 지정

Root<Entity> e = cq.from(Entity.class);
// FROM 절
// 쿼리 루트이며, 시작점이다.
cq.select(e);
// SELECT 절
// eq.from(Entity.class).select(e). 형태로 사용 가능하다.

// Predicate fieldEqual = cb.equal(e.get("field", "value");
// Order orderField = cb.desc(e.get("field));
// Predicate greatherThenField = cb.greaterThen(e.<Integer>get("field"), 10);
// 위와 같이 cb 에 조건 등을 추가 하여 쿼리를 작성 할 수 있다.
// greatherThen 에 제네릭 타입 정보를 전달했는데, e.get("field") 를 통해서는 반환 정보를 알 수 없어서 명시해줘야 한다.
// 참고로 greatherThen() 대신에 gt() 를 사용해도 된다.

TypedQuery<Entity> query = em.createQuery(cq);
List<Entity> entities = query.getResultList();
```

#### Criteria 쿼리 생성

```java
public interface CriteriaBuilder {
    CriteriaQuery<Object> createQuery();
    // 조회값 반환 타입 : Object
    
    <T> CriteriaQuery<T> createQuery(Class<T> resultClass);
    // 조회값 반환 타입 : Entity, 임베디드 타입, 기타
    
    CriteriaQuery<Tuple> createTupleQuery();
    // 조회값 반환 타입 : Tuple
    
    <Y> CompoundSelection<Y> construct(Class<Y> resultClass, Selection<?>... selections)
    // JPQL 의 new construct()
}
// CriteriaBuilder

CriteriaBuilder cb = em.getCriteriaBuilder();

CriteriaQuery<Entity> cq = cb.createQuery(Entity.class);
// Entity 로 반환값 설정

CriteriaQuery<Object> cq = cb.createQuery();
// 반환 타입을 지정할 수 없거나 반환 타입이 둘 이상일 때, 위와 같이 설정한다.
// 반환 타입이 2개 이상일 경우에는 Object[] 로 설정하는게 편하다.
// -> row 단위로 묶여서 나오기 때문에

CriteriaQuery<Tuple> cq = cb.createTupleQuery();
// 반환 타입을 튜플로 받고 싶을 경우, 위와 같이 설정한다.
// CriteriaQuery<Tuple> cq = cb.createQuery(Tuple.class); 와 같다.

List<Entity> resultList = em.createQuery(cq).getResultList();
```

#### Criteria 조회

```java
public interface CriteriaQuery<T> extends AbstractQuery<T> {
    CriteriaQuery<T> select(Selection<? extends T> selection);
    // 한 건 지정
    
    CriteriaQuery<T> multiselect(Selection<?>... selections);
    // 여러 건 지정
    
    CriteriaQuery<T> multiselect(List<Selection<?>> selectionList);
    // 여러 건 지정
    
    ...
}

...
// Criteria 쿼리 생성 후, 조회 (select) 설정을 한다.

cq.select(e);
// JPQL 의 SELECT e

cq.multiselect(e.get("field1"), e.get("field2"));
// JPQL 의 SELECT e.field1, e.field2

cq.select(cb.array(e.get("field1"), e.get("field2")));
// cb.array 으로도 여러건 조회가 가능하다.
// JPQL 의 SELECT e.field1, e.field2

cq.multiselect(e.get("field1"), e.get("field2")).distinct(true);
// JPQL 의 SELECT DISTINCT e.field1, e.field2

cq.select(cb.construct(SomeDTO.class, e.get("field1")m, e.get("field2")))
// DTO 의 형태로 특정 데이터만 뽑을 때, cb.construct 를 사용한다.
TypedQuery<SomeDTO> query = em.createQuery(cq);
List<SomeDTO> resultList = query.getResultList();
// JPQL 의 SELECT new 패키지.경로.SomeDTO(e.field1, e.field2) FROM Entity e
```

##### Tuple 형태로 조회하는 예제

* Tuple 을 이름 기반으로 조회하므로, Object[] 보다 안전하다.
* tuple.getElements() 메소드를 통해서 현재 튜플의 별칭과 자바 타입도 조회할 수 있다.

```java
// JPQL : SELECT e.field1, e.field2 FROM Entity e

CriteriaBuilder cb = em.getCriteriaBuilder();

CriteriaQuery<Tuple> cq = cb.createTupleQuery();

Root<Entity> e = cq.from(Entity.class);

cq.multiselect(
        e.get("field1").alias("field1"), // alias 를 설정할 수 있다.
        e.get("field2").alias("field2") // tuple 을 사용할 때는 별칭 설정은 필수이다.
);
/*
엔티티를 통해 조회할 수 있다.
cq.select(
    cb.tuple(
        e.alias("e"), // Entity 를 e 라는 별칭으로 조회할 수 있다.
        e.get("field2").alias("field2")
    )
);

...

Entity field1 = tuple.get("e", Entity.class);
 */

TypedQuery<Tuple> query = em.createQuery(cq);
List<Tuple> resultList = query.getResultList();
for (Tuple tuple : resultList) {
    String field1 = tuple.get("alias", String.class);
    // 별칭으로 조회
    Integer field2 = tuple.get("field2", Integer.class);
}
```

#### GroupBy

```java
...

Expression maxAge = cb.max(e.<Integer>get("age"));

cq.multiselect(e.get("field1"), maxAge)
    .groupBy(e.get("field2"));

...

// JPQL
// SELECT e.field1, MAX(e.age) FROM Entity e GROUP BY e.field2
```

#### Having

```java
...

Expression minAge = cb.min(e.<Integer>get("age"));

cq.multiselect(e.get("age"), minAge)
    .groupBy(e.get("field2"))
    .having(cb.gt(minAge, 10));

...

// JPQL
// SELECT e.field1, MIN(e.age) FROM Entity e GROUP BY e.field2 HAVING MIN(e.age) > 10
```

#### 정렬

```java
cq.select(e)
    .orderBy(cb.desc(e.get("field")));

// JPQL
// SELECT e.* FROM Entity e ORDER BY e.field desc
```

* 정렬 API
    * CriteriaQuery<T> orderBy(Order... o);
    * CriteriaQuery<T> orderBy(List<Order> o);

#### 조인

```java
public enum JoinType {
    INNER,  // 내부 조인
    LEFT,   // 왼쪽 외부 조인
    RIGHT,  // 오른쪽 외부 조인 (JPA 구현체나 데이터베이스에 따라 지원하지 않을 수 있음)
}

...

Root<Entity> e = cq.from(Entity.class);
Join<Entity, Parent> p = e.join("parent", JoinType.INNER);

// e.join("parent");                내부조인
// e.join("parent", JoinType.LEFT); 외부 조인
// e.fetch("parent", JOinType...);  fetch 조인도 가능하다.

cq.multiselect(e, p)
    .where(cb.equal(p.get("field"), "value"));

/*
JPQL

SELECT e, p FROM Entity e
INNER JOIN e.parent p
WHERE e.field = 'value'
 */
```
