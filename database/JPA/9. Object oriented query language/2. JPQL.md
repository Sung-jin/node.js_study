### JPQL 특징

1. JPQL 은 객체지향 쿼리 언어이다. 따라서 테이블을 대상으로 쿼리하는 것이 아닌, 엔티티 객체를 대상으로 쿼리한다.
2. JPQL 은 SQL 을 추상화해서 특정 데이터베이스 SQL 에 의존하지 않는다.
3. JPQL 은 결국 SQL 로 변환된다.

* 예제 도메인 모델

![](../images/8.JPQL_model.png)

#### 기본 문법과 쿼리 API

* JPQL 는 SELECT, UPDATE, DELETE 가 존재하지만, em.persist() 때문에 INSERT 은 없다.
* select 문 사용
    * ex) SELECT m FROM Member AS m where m.field = ''
    * 엔티티와 속성은 대소문자를 구분한다.
        *  Member, field 등은 대소문자를 구분한다.
        * JPQL 키워드 (SELECT, FROM, AS ...) 에 해당하는 키워드들은 대소문자를 구분하지 않는다.
    * @Entity(name = "") 으로 짓지않으면, 클래스 명을 기본값으로 매핑한다.
    * ... Member AS m ... 과 같은 별칭은 필수이다. (AS 는 생략이 가능하다.)
    
#### TypeQuery, Query

* JPQL 을 실행하기 위해서는 쿼리 객체를 만들어줘야 한다.
* 쿼리 객체에 반활할 타입을 명학하게 지정할 때는 TypeQuery 객체를 사용한다.
* 반대로 타입을 명확하게 지정할 수 없으면 Query 객체를 사용한다.

```java
TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
// 결과를 예제로 반환한다. 만약 결과가 없다면 빈 컬렉션을 제줄한다.
Query query = em.createQuery("SELECT m FROM Member m", Member.class);
// Query 결과는 Object 배열을 제공한다.

// query.getSingleResult();
// 결과가 정확히 1개일 때 사용한다.
// 결과가 없으면 javax.persistence.NoResultException 예외 발생
// 결과가 1개보다 많으면 javax.persistence.NoUniqueResultException 이 발생한다.
```

#### 파라미터 바인딩

* 이름 기준 파라미터
    * 파라미터를 이름으로 구분하는 방법
    * 이름 기준 파라미터는 앞에 : 을 붙인다.

```java
String parameter = "param";

TypedQuery<Entity> query = em.createQuery("select ... from ... where m.column = :parameter", Entity.class);
query.setParameter("parameter", parameter);
List<Entity> results = query.getResultList();

// JPA 는 메소드 체인 방식으로 설계되어 있어서 다음과 같이 작성할 수 있다.

List<Entity> results = em.createQuery("select ... from ... where m.column = :parameter", Entity.class)
    .setParameter("parameter", parameter)
    .getResultList();
```

* 위치 기준 파라미터
    * ? 다음에 위치 값을 주면 된다.

```java
String parameter = "param";

List<Entity> results = em.createQuery("select ... from ... where m.column = ?1", Entity.class)
    .setParameter(1, parameter)
    .getResultList();
```

* 참고로 위치 기준 파라미터 방식보다는, 이름 기준 파라미터 바인딩 방식이 더 명확하다.
