### 벌크 연산

* 여러건의 엔티티를 수정/삭제 등을 하나씩 처리하기에는 시간이 오래걸린다.
    * 이럴때 벌크 연산을 사용하면 된다.

```java
String qlString = """
    UPDATE Product p
    SET p.price = p.price * 1.1
    WHERE p.field < :field
"""

int resultCount = em.createQuery(qlString)
                    .setParameter("value", 100)
                    .executeUpdate();
// executeUpdate() 를 사용하면 벌크 연산을 한다.
// 삭제 쿼리를 사용할 때도 똑같이 executeUpdate() 를 사용하면 된다.
// JPA 표준은 아니지만, 하이버네이트는 insert 벌크 연산도 지원한다.
```

#### 벌크 연산의 주의점

* 벌크 연산시 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다.

```java
Product productA = em.createQuery("SELECT p FROM Product p WHERE p.name = :name", Product.class)
                    .setParameter("name", "value")
                    .getSingleResult();
// 현재 영속성 컨텍스에 저장된 엔티티의 field 가 1000 이라고 가정을 하자.

em.createQuery("UPDATE Product p SET p.field = p.field * 1.1")
    .executeUpdate();

// 벌크 연산 후에 영속성 컨텍스트에 존재하는 해당 엔티티들의 값은 업데이트 되지 않는다.
```

* 위와 같은 이슈에서 해결방안
    1. em.refresh() 사용
    2. 벌크 연산먼저 실행 후, 데이터 조회
    3. 벌크 연산 후 영속성 컨텍스트 초기화

#### 영속성 컨텍스트와 JPQL

* JPQL 의 조회를 통해 가져온 객체들 중, 엔티티는 영속성 컨텍스트에 관리되고 나머지 것들은 관리되지 않는다.
    * 임베디드 타입, 값 타입 등은 관리되지 않는다.
* JPQL 을 통해 조회한 엔티티와 영속성 컨텍스트
    1. JPQL 로 조회를 요청
    2. JPQL 은 SQL 로 변환되어 데이터베이스를 조회
    3. 조회 결과와 영속성 컨텍스트를 비교
    4. 데이터베이스 결과 중 식별자 값 기준으로 영속성 컨텍스트에 존재하면, 해당 객체는 버리고 없으면 영속성 컨텍스트에 추가한다.
    5. 결과 객체들의 반환값은 영속성 컨텍스트에 존재하는 객체들을 반환한다.
* 새로운 객체를 바탕으로 대체한다면?
    1. 새로운 엔티티를 영속성 컨텍스트에 하나 더 추가한다.
        * 영속성 컨텍스트는 기본 키 값을 기준으로 엔티티를 관리한다.
    2. 기존 엔티티를 새로 검색한 엔티티로 대체한다.
        * 영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있다.
        * 영속성 컨텍스트는 엔티티의 동일성을 보장한다.
    3. 기존 엔티티는 그대로 두고 새로 검색한 엔티티를 버린다.
        * 위의 이유들로 인해 3번에 해당되는 방식으로 영속성 컨텍스트가 관리된다.
        
#### find() vs JPQL

* em.find 를 통한 조회는 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는다.
* 영속성 컨텍스트에 조회하고자 하는 객체가 존재한다면, 캐싱에 의한 성능상 이점이 존재한다.

```java
Member member1 = em.find(Member.class, 1L);
Member member2 = em.find(Member.class, 1L);
// member1 == member2 의 주소는 같다.
// 즉, 두 개의 데이터는 같다.
```

* JPQL 의 경우에는 결과 데이터는 모두 같은 객체이지만, 내부적으로 동작하는 방식이 다르다.
    * find() 의 경우 엔티티 컨텍스트를 먼저 찾지만, JPQL 은 데이터베이스를 먼저 조회한다.
    * 그리고 위에서 JPQL 을 통해 조회한 엔티티와 영속성 컨텍스트에 정리한 방식대로 동작한다.

```java
Member member1 = em.createQuery("SELECT m FROM m WHERE m.id = :id", Member.class)
                    .setParameter("id", 1)
                    .getSingleResult();
Member member2 = em.createQuery("SELECT m FROM m WHERE m.id = :id", Member.class)
                    .setParameter("id", 1)
                    .getSingleResult();

// member1 == member2 의 주소는 같다.
// 하지만 내부적으로 동작하는 방식은 다르다.
```
