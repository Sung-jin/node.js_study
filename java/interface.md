# 인터페이스

* 인터페이스는 객체의 사용 방법을 정의한 타입이라 할 수 있다.
* java8 의 lambda 는 함수적 인터페이스의 구현 객체를 생성하여 동작하도록 되어 있다.
* 인터페이스를 사용하면 객체의 교환성을 높여주기 때문에 다형성을 구현하는데 매우 중요한 역할을 한다.
    * 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.
    * 개발 코드가 인터페이스의 메소드 호출 -> 인터페이스가 객체의 메소드를 호출 -> 객체가 응답 -> 인터페이스가 응답 하는 형태로 진행이 되며, 이렇게 구성됨으로써 개발 코드는 객체의 내부 주소를 알 필요 없이 인터페이스의 메소드만 알면 된다.
    * 인터페이스를 사용하면 개발 코드를 수정하지 않고 인터페이스를 변경하여 인터페이스를 사용하는 모든 개발 코드가 동일한 입력과 기능, 출력을 보장시켜줄 수 있다.
    * 또한, 인터페이스를 사용하는 객체에 따라서 실행 로직과 응답값이 다르게 동작 할 수 있다.
* 인터페이스는 class 키워드 대신 interface 키워드로 선언한다.
* 인터페이스는 상수와 메소드만 가질 수 있다.
* java8 이후부터는 디폴트 메소드와 정적 메소드를 선언할 수 있다.
* 인터페이스에 선언 가능한 종류
    1. Constant Field - 인터페이스에는 필드를 선언 할 수 없지만, 상수값은 고정 된 값이므로 선언하여 사용할 수 있다.
    2. Abstract Method - 메소드명과 매개 변수만 존재하는 추상 메소드를 선언할 수 있으며, 인터페이스를 사용하는 객체는 반드시 추상 메소드의 구현을 해야 한다.
    3. Defualt Method - 인터페이스를 상속한 구현 객체가 가지고 있는 인스턴스 메소드이다.
    4. Static Method - 인터페이스를 상속한 구현 객체가 없더라도 인터페이스만으로도 호출이 가능한 메소드이다.

* 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행되기 때문에 인터페이스에 구현부가 없으며, 리턴 타입과 메소드명과 매개변수만 기술되고 로직이 없다. -> Abstract Method
* 

```JAVA
public interface A() {
    public static final int CONSTANT_VAL1 = 0;
    int CONSTANT_VAL2 = 1;
    // public static final 키워드를 생략하더라도 컴파일 시 자동으로 붙여준다.

    void add(int a, int b)
    // public abstract 를 생략하더라도 컴파일 시 자동으로 붙여준다.

    default void greeting() {
        print('Hello');
    }
    // public 속성을 가지며, 생략되더라도 컴파일 시 자동으로 붙는다.

    static void greetingStatic() {
        print('Hi there~!');
    }
    // public 속성을 가지며, 생략되더라도 컴파일 시 자동으로 붙는다.
}
```