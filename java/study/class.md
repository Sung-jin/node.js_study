# 객체 지향 프로그래밍

- Object Oriented Programming
- 객체들을 만들어서 이러한 객체를 조립하여 완성된 프로그램을 만드는 기법
- 다음 단계를 거쳐서 OOP 를 하게 된다.
  1. 클래스를 설계한다.
  2. 설계 된 클래스를 바탕으로 객체를 생성한다.
  3. 생성 된 객체를 잘 이용한다. ㅎㅎ

## Object (객체)

- 객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중 자신의 속성을 가지고 있으며 다른 것들과 식별 가능한 것을 말한다.
- 객체는 속성 (그 객체의 특징), 동작 (그 객체의 행위) 가 존재하며 OOP 에서 속성을 field, 동작을 method 라고 표현한다.
- 객체간에는 독립적으로 존재하며 객체간에 상호작용을 통해 동작한다.
  - A 객체의 field 를 통해 method 가 실행되고 그 결과를 다른 B 객체에 넘겨서 상호작용할 수 있다.
  - 자바에서 객체의 field 와 method 를 접근할 때 '**.**' 을 이용해서 접근할 수 있다.
    - 접근 제한자에 의해 접근할 수 있는 범위와 방법이 달라 질 수 있다.
- 객체간의 관계는 집합 관계, 사용 관계, 상속 관계가 있다.

## Encapsulation (캡슐화)

- 객체의 field, method 를 묶고, 실제 구현 내용을 감추는 것을 말한다.
- 외부 객체는 객체 내부를 알 수 없으며, 캡슐화 된 객체가 노출한 field 와 method 만 접근할 수 있다.
- 이러한 접근을 제어하기 위해 Access Modifier (접근 제한자) 를 사용한다.

## Inheritance (상속)

- 부모가 가지고 있는 field 와 method 를 자식 객체에게 상속하여 전달하는 것을 말한다.
  - 상속받은 객체는 부모의 모든 속성을 사용할 수 있으며 추가적으로 다른 속성을 정의하여 사용할 수 있다.
  - 상속받은 속성을 재 정의하여 사용할 수도 있다.
- 상속을 통해 다른 객체를 빠르게 설계할 수 있으며, 재사용성을 높여서 중복 코드를 방지할 수 있다.
- 상속받은 부모의 속성을 수정하게 되면, 상속받은 모든 자식에 적용되어 유지보수에 유리하다.

## Polyorphism (다형성)

- 같은 타입이지만, 그 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
- 부모 타입에 모든 자식 객체가 대입될 수 있으며, 인터페이스 타입에는 모든 구현 객체가 대입 될 수 있다.
- 객체의 부품화가 가능하다.

## Class (클래스)

- 클래스 안에 method 와 field 가 존재하며, 이를 해당 클래스의 instance 라고 한다.
- constructor (생성자) 를 통해 객체 생성 시 초기화를 해주는 역할도 존재한다.
- 클래스 선언에는 다음과 같은 규칙이 있다.
  1. 하나 이상의 문자로 이루어져야 한다.
  2. 첫 번째 글자에는 숫자가 올 수 없다.
  3. \$, \_ 외의 특수 문자는 사용할 수 없다.
  4. 자바 키워드는 사용할 수 없다.
  5. 한글도 가능하지만.. 영어로 합시다.
  6. 관례적으로 단어의 첫번째 글자는 대문자로 하며 단어가 1개라도 대문자로 시작된다.
- 설계한 클래스를 생성할 때 new 연산자를 통해 heap area 에 객체를 생성하여 사용한다.
  - new 연산자는 heap area 에 객체를 생성한 후, 그 객체의 주소를 리턴한다.
  - 같은 클래스를 new 연산자를 통해 생성하더라도, 각자 고유한 객체가 생성된다.

## Field (필드)

- 객체의 고유 데이터, 상태 데이터 등을 저장할 수 있는 영역
- 생성자와 메소드 중괄호 블록 내부를 제외한 모든 {} 블록 안에서 선언이 가능하며, 그 블록의 로컬 변수가 된다.

## Constructor (생성자)

- new 연산자를 통해 클래스 객체를 생성 할 때 호출된다.
- 생성자를 통해 field 를 초기화, 메소드를 호출 등을 할 수 있다.
- new 연산자를 통해 객체가 생성되면 heap area 객체가 생성되고 객체의 주소가 리턴된다.
- 생성자의 매개변수가 다르게 여러번 선언 할 수 있다. (생성자 overloading)
  - overloading 된 생성자끼리 this(arg1, arg2, ...) 형태로 다른 인자를 가진 생성자를 호출 할 수 있다.
  - 생성자 내부의 this() 로 다른 생성자 호출은 첫 라인에 있어야만 한다.
- 클래스에 생성자 없이 선언할 수 있는데, 이때는 비어있는 기본 생성자를 자동으로 만들어주며 생성자를 선언하면 기본 생성자는 자동으로 생성되지 않는다.

## Method (메소드)

- 메소드 선언은 다음과 같은 형태를 가진다.
  - 선언부 (signature) - 리턴타입, 메소드 이름, 매개변수 선언
  - 실행 블록 (로직)
- 리턴 타입에 따라 메소드의 결과가 정해지며 리턴타입이 없을 수 있다.
- 메소드 이름
  - 숫자로 시작하면 안되며 \$, \_ 를 제외한 특수문자를 사용하면 안된다.
  - 관례적으로 소문자로 시작한다.
  - 단어와 단어 사이는 대문자로 시작한다.
- 객체 외부 (클래스로 초기화 한 객체) 의 내부 메소드를 사용 할 경우 . 을 통해 접근하여 사용 할 수 있다.
- 같은 이름의 메소드를 매개 변수만 다르게 하여 overloading 하여 생성할 수 있다.
  - 같은 이름이지만 매개 변수에 따라 내부 로직을 다르게하여 선언 할 수 있다.

## Instance

- 인스턴스 멤버란 객체(인스턴스) 를 생성한 후 사용할 수 있는 필드와 메소드를 말한다.
- 클래스 내부에 선언된 필드와 메소드가 각각 인스턴스 필드와 인스턴스 메소드이며 이는 객체 없이는 사용될 수 없다.
  - 인스턴스 필드는 객체마다 존재한다.
  - 인스턴스 메소드는 메소드 영역에 공유되어 사용된다.

## This

- 블록 내부의 인스턴스 멤버에 접근할 때 사용된다.

## Static

- static(정적) 키워드를 통해 멤버를 선언 할 경우, 객체를 생성하지 않아도 사용 할 수 있다.
- 정적 필드의 경우 선언과 동시에 초기화 하는것이 보통이다.
  - 정적 필드의 블럭을 통해 초기화 작업을 할 수 있다.
  - 정적 블록은 클래스가 메모리에 로딩될 때 자동으로 실행된다.
- 객체가 없어도 실행이 될 수 있기 때문에 정적 멤버는 내부 인스턴스 필드와 인스턴스 메소드를 사용 할 수 없고, this 키워드를 사용 할 수 없다.
  - 인스턴스 멤버를 사용하고 싶다면 static 블록 안에 객체를 생성하고 참조 변수로 접근해야 한다.

```JAVA
public class Hello () {
    static int world = 1;
    static void hi() {
        print("hello");
    }
    static int foo;

    int bar;
    public void fooBar() {
        print("foo bar");
    }

    static {
        foo = 1 + 1;
    }

    static {
        bar = 1;
        this.bar = 2;
        fooBar();
        this.fooBar();
        // 모두 컴파일 에러
    }

    static void method() {
        HelloWorld helloWrold = new HelloWorld();
        helloWrold.field = 1;
        helloWrold.method();
    }
    ...
}

...

public static void main(String[] args) {
    ...
    print(Hello.world); // 1
    Hello.hi(); // hello
    print(Hello.foo); // 2
}
```

## Singleton (싱글톤)

- 단 하나의 객체만 만들도록 보장되어야 하는 경우가 있으며 이를 싱글톤이라 한다.
- 싱글톤으로 만들기 위해서는 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.
  - new 를 통해 생성자를 호출하면, 그 호출한 만큼 객체를 만들기 때문이다.
  - 생성자에 pirvate 접근 제한자를 주면 된다.
  - 자신의 타입인 정적 필드를 private으로 하나 선언하여 그 필드를 통해 자신의 객체를 생성해 초기화 한다.
  - getInstance 메소드를 통해 초기화 한 필드를 return 해준다.

```JAVA
public class Foo {
    private static foo singleton = new Foo();

    private Foo() {}

    static Foo getInstance() {
        return singleton;
    }
}
...

public static void main(String[] args) {
    Foo foo1 = Foo.getInstance();
    Foo foo2 = Foo.getInstance();

    // foo1, foo2 는 동일한 객체를 참조한다. (동일한 주소를 가진 값을 본다.)
    ...
}
```

## Final

- final 키워드를 붙이면 그 필드는 더이상 변함이 없이 초기화 된 값으로 고정된다.
- final 키워드를 초기화 하는 경우는 필드 선언시 초기화와 생성자를 통한 초기화가 있다.
- final 키워드가 있는 필드가 초기화 되지 않으면 컴파일 에러가 발생한다.
- final 키워드만 있어서는 상수로 볼 수 없다.
  - final 을 통해 값은 변경 할 수 없지만, 초기화를 통해 다르게 저장 할 수 있기 때문이다.
  - final static 키워드를 사용하면 이는 상수가 되는데, static 을 통해 객체마다 생성되지 않으며 클래스에만 포함되고 final 을 통해 값을 고정하기 때문이다.
  - 상수 이름은 모두 대문자로 작성하고 단어와 단어 사이는 \_ 를 통해 구분하는게 관례이다.

## Package

- 자바에서 클래스를 체계적으로 관리하기 위해 패키지를 사용한다.
- 패키지의 물리적인 형태는 파일 시스템의 폴더이다.
- 패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다.
- 패키지 규칙
  - 숫자로 시작해서는 안되고 \_ \$ 를 제외한 특수문자를 사용해서는 안된다.
  - java 로 시작하는 자바 표준 API 패키지이다.
  - 모두 소문자로 작성하는게 관례적이다.
- 패키지는 (회사) 도메인 이름으로 패키지를 만든다.

## Import

- 다른 패키지에 속하는 클래스를 사용하기 위해서는 import 를 해줘야 사용 할 수 있다.
- 패키지에 _ 을 넣을 수 있는데, 이는 _ 전까지의 해당되는 모든 패키지를 의미한다.

~~요즘 IDE가 좋아서 import 나 package 는 모두 알아서 추가해준다~~

## Access Modifier (접근 제한자)

- 외부 클래스에서 내부 인스턴스에 접근 할 수 있는 레벨을 지정한다.
- 특정 필드와 메소드를 보호하거나 외부에서 접근 할 수 없도록 할 때 사용한다.
- 접근 제한자 종류
  1. public - public 으로 되어 있으면 어떤 외부 클래스라도 접근 할 수 있다.
  2. protected - 같은 패키지 또는 자식 클래스에서 접근 할 수 있다.
  3. default - 접근 제한자를 아무 키워드도 작성하지 않았을 시 default 제한을 가지게 되며, 같은 패키지에 소속된 클래스에서만 사용 할 수 있다.
  4. private - 내부 클래스 안에서만 접근을 허용한다.
- 접근 제한자는 클래스, 생성자, 필드, 메서드 모두 사용 할 수 있으며 종류에 따라 접근을 제한된다.

## Getter, Setter

- 객체 지향 프로그래밍에서 객체의 데이터는 외부에서 직접 접근을 막는다.
  - 외부에서 객체의 데이터를 마음대로 변경할 경우 객체의 무결성이 깨질 수 있기 때문이다.
- 객체 필드를 private 으로 제한을 하고 setter 메소드를 통해 필드 값을 변경하고 getter 메소드를 통해 필드의 값을 읽을 수 있게 한다.
  - 직접 대입하는 방식에서 setter 를 사용하게 되면, 로직을 통해 validation 이나 가공을 할 수 있고 getter 도 같다.

## Annotation (어노테이션)

- 어노테이션은 application 이 처리해야 할 데이터가 아닌, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 지 알려주는 metadata 라고 할 수 있다.
- 어노테이션은 다음의 용도로 사용된다.
  1. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
  2. 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
  3. 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공
- @Overide 어노테이션이 대표적이며, 이는 메소드가 재정이 되었음을 명시해준다.
- 어노테이션 타입을 정의하는 방식은 인터페이스를 정의하는 것과 유사하다.
- 어노테이션은 적용할 수 있는 대상을 지정할 수 있으며 java.lang.annotation.ElementType 열거 상수에 정의되어 있다.
  - 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다.
  - 배열 형태로 여러곳을 정의할 수 있다.

| 열거 상수       | 적용 대상                    |
| --------------- | ---------------------------- |
| TYPE            | 클래스, 인터페이스, 열거타입 |
| ANNOTATION_TYPE | 어노테이션                   |
| FIELD           | 필드                         |
| CONSTRUCTOR     | 생성자                       |
| METHOD          | 메소드                       |
| LOCAL_VARIABLE  | 로컬 변수                    |
| PACKAGE         | 패키지                       |

- 유지할 범위를 지정하는 어노테이션 유지 정책은 java.lang.annotation.RetentionPolicy 열거 상수에 정의되어 있다.
- @Retention 을 사용하여 설정한다.

| 열거 상수 | 설명                                                                                                    |
| --------- | ------------------------------------------------------------------------------------------------------- |
| SOURCE    | 소스상에서만 어노테이션 정보를 유지한다. 바이트 코드 파일에 정보가 남지 않는다.                         |
| CLASS     | 바이트 코드 파일까지 어노테이션의 정보를 유지하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수 없다. |
| RUNTIME   | 바이트 코드 파일에 어노테이션 정보를 유지하며, 리플렉션을 이용해 런타임 중에도 정보를 얻을 수 있다.     |

- 런타임 시에 어노테이션이 적용되었는지 확인 및 엘리먼트 값을 이용해 특정 작업이 가능하다.
- java.lang.Class 의 아래 표 메소드를 통해 java.lang.reflect 패키지의 타입의 배열을 얻어야 한다.
  - isAnnotationPresent(Class<? extends Annotation> annoationClass) - 지정한 어노테이션이 적용되었는지 여부. Class 에서 호출했을 경우 상위 클래스에 적용된 경우에도 true (boolean)
  - getAnnotation(Class<T> annotationClass) - 지정한 어노테이션이 적용되어 있으면 어노테이션을, 아니면 null 을 리턴한다. Class 에서 호출했을 경우 상위클래스에 적용된 경우에도 어노테이션을 리턴한다. (Annotation)
  - getAnnotations() - 적용된 모든 어노테이션을 리턴한다. Class 에서 호출했을 경우 상위 클래스에 적용된 어노테이션 모두 포함되며, 적용된 어노테이션이 없으면 []을 리턴한다. (Annotation[])
  - getDeclaredAnnotations() - 직접 적용된 모든 어노테이션을 리턴하며, Class 에서 호출하고 상위 클래스에 적용 된 어노테이션이 있더라도 **직접 적용 된** 어노테이션만 리턴한다. (Annotation[])

| 리턴 타입     | 메소드명 (매개변수)  | 설명                                  |
| ------------- | -------------------- | ------------------------------------- |
| Field[]       | getFields()          | 필드 정보를 Field 배열로 리턴         |
| Construcotr[] | getConstructors()    | 생성자 정보를 Constructor 배열로 리턴 |
| Method[]      | getDeclaredMethods() | 메소드 정보를 Method 배열로 리턴      |

```JAVA
@Target(ElementType.BLABLA..., ElementType.BLABLA..., ElementType.BLABLA...)
@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation {
    String arg1(); // 기본값이 없으므로 위 어노테이션을 사용할 경우 반드시 arg1 에 대한 값을 지정해줘야 한다.
    Int arg2() defualt 1;
}
// 어노테이션 타입 정의

@Annotation(arg = "", ....)
```

## Reflection

- 런타임 시에 클래스의 메타 정보를 얻는 기능
  - 필드의 정보
  - 생성자 정보
  - 메소드 정보
  - 어노테이션 정보
